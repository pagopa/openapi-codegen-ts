// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`gen-api-models should generate a dictionary from additionalProperties: additional-properties 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";

// additional attributes

export const AdditionalPropsTest = t.dictionary(
  t.string,

  t.readonlyArray(t.number, \\"array of number\\"),

  \\"AdditionalPropsTest\\"
);

export type AdditionalPropsTest = t.TypeOf<typeof AdditionalPropsTest>;
"
`;

exports[`gen-api-models should generate a dictionary from additionalProperties: true: additional-properties-true 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";

// additional attributes

export const AdditionalPropsTrueTest = t.dictionary(
  t.string,
  t.any,
  \\"AdditionalPropsTrueTest\\"
);

export type AdditionalPropsTrueTest = t.TypeOf<typeof AdditionalPropsTrueTest>;
"
`;

exports[`gen-api-models should generate a type intersection from allOf: all-of-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { Message } from \\"./Message\\";
import { PaginationResponse } from \\"./PaginationResponse\\";

// required attributes
const AllOfTest1R = t.interface({});

// optional attributes
const AllOfTest1O = t.partial({
  items: t.readonlyArray(Message, \\"array of Message\\")
});

export const AllOfTest1 = t.intersection(
  [AllOfTest1R, AllOfTest1O],
  \\"AllOfTest1\\"
);

export type AllOfTest1 = t.TypeOf<typeof AllOfTest1>;

export const AllOfTest = t.intersection(
  [AllOfTest1, PaginationResponse],
  \\"AllOfTest\\"
);

export type AllOfTest = t.TypeOf<typeof AllOfTest>;
"
`;

exports[`gen-api-models should generate a type union from allOf when x-one-of is used: allofoneof-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { Message } from \\"./Message\\";
import { PaginationResponse } from \\"./PaginationResponse\\";

/**
 * test if we can use allOf as oneOf
 */

// required attributes
const AllOfOneOfTest1R = t.interface({});

// optional attributes
const AllOfOneOfTest1O = t.partial({
  items: t.readonlyArray(Message, \\"array of Message\\")
});

export const AllOfOneOfTest1 = t.intersection(
  [AllOfOneOfTest1R, AllOfOneOfTest1O],
  \\"AllOfOneOfTest1\\"
);

export type AllOfOneOfTest1 = t.TypeOf<typeof AllOfOneOfTest1>;

export const AllOfOneOfTest = t.union(
  [AllOfOneOfTest1, PaginationResponse],
  \\"AllOfOneOfTest\\"
);

export type AllOfOneOfTest = t.TypeOf<typeof AllOfOneOfTest>;
"
`;

exports[`gen-api-models should generate a type union from oneOf: oneof-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";

// required attributes
const OneOfTest1R = t.interface({});

// optional attributes
const OneOfTest1O = t.partial({
  limited: t.boolean
});

export const OneOfTest1 = t.intersection(
  [OneOfTest1R, OneOfTest1O],
  \\"OneOfTest1\\"
);

export type OneOfTest1 = t.TypeOf<typeof OneOfTest1>;

// required attributes
const OneOfTest2R = t.interface({});

// optional attributes
const OneOfTest2O = t.partial({
  unlimited: t.boolean
});

export const OneOfTest2 = t.intersection(
  [OneOfTest2R, OneOfTest2O],
  \\"OneOfTest2\\"
);

export type OneOfTest2 = t.TypeOf<typeof OneOfTest2>;

export const OneOfTest = t.union([OneOfTest1, OneOfTest2], \\"OneOfTest\\");

export type OneOfTest = t.TypeOf<typeof OneOfTest>;
"
`;

exports[`gen-api-models should generate the operator definition 1`] = `
"
    /****************************************************************
     * testAuthBearer
     */

    // Request type definition
    export type TestAuthBearerT = r.IGetApiRequestType<{readonly bearerToken: string,readonly qo?: string,readonly qr: string,readonly cursor?: string}, \\"Authorization\\", never, r.IResponseType<200, undefined>|r.IResponseType<403, undefined>>;
  
      
    export const testAuthBearerDefaultResponses = {
      200: t.undefined, 403: t.undefined
    };
  
      
    export type TestAuthBearerResponsesT<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined> = {
      200: t.Type<A0, C0>, 403: t.Type<A1, C1>
    };
  
      export function testAuthBearerDecoder<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined>(overrideTypes: Partial<TestAuthBearerResponsesT<A0, C0, A1, C1>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<403, A1, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testAuthBearerDefaultResponses as unknown as TestAuthBearerResponsesT<A0, C0, A1, C1>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
    const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"]>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
  
    const d403 = (type[403].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 403>(403, undefined) 
        : r.ioResponseDecoder<403, (typeof type[403])[\\"_A\\"], (typeof type[403])[\\"_O\\"]>(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A1, never>>;
  
        return r.composeResponseDecoders(d200, d403)
      }

      // Decodes the success response with the type defined in the specs
      export const testAuthBearerDefaultDecoder = () => testAuthBearerDecoder();"
`;

exports[`gen-api-models should handle CustomStringFormats: custom-string-format 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { SomeCustomStringType as SomeCustomStringTypeT } from \\"italia-ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type CustomStringFormatTest = t.TypeOf<typeof CustomStringFormatTest>;
export const CustomStringFormatTest = SomeCustomStringTypeT;
"
`;

exports[`gen-api-models should handle NonNegativeIntegers: non-negative-integer 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { NonNegativeInteger } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type NonNegativeIntegerTest = t.TypeOf<typeof NonNegativeIntegerTest>;
export const NonNegativeIntegerTest = NonNegativeInteger;
"
`;

exports[`gen-api-models should handle NonNegativeNumbers: non-negative-numbers 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { NonNegativeNumber } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type NonNegativeNumberTest = t.TypeOf<typeof NonNegativeNumberTest>;
export const NonNegativeNumberTest = NonNegativeNumber;
"
`;

exports[`gen-api-models should handle WithinRangeIntegers: within-range-integer 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { WithinRangeInteger } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type WithinRangeIntegerTest = t.TypeOf<typeof WithinRangeIntegerTest>;
export const WithinRangeIntegerTest = WithinRangeInteger(0, 11);
"
`;

exports[`gen-api-models should handle WithinRangeNumbers: within-range-numbers 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { WithinRangeNumber } from \\"italia-ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type WithinRangeNumberTest = t.TypeOf<typeof WithinRangeNumberTest>;
export const WithinRangeNumberTest = WithinRangeNumber(0, 10);
"
`;

exports[`gen-api-models should handle WithinRangeStrings: within-range-strings 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { WithinRangeString } from \\"italia-ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type WithinRangeStringTest = t.TypeOf<typeof WithinRangeStringTest>;
export const WithinRangeStringTest = WithinRangeString(10, 11);
"
`;

exports[`gen-api-models should handle enums: enum-simple 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { enumType } from \\"italia-ts-commons/lib/types\\";

export enum StatusEnum {
  \\"value1\\" = \\"value1\\",

  \\"value2\\" = \\"value2\\",

  \\"value3\\" = \\"value3\\"
}

// required attributes
const EnumTestR = t.interface({});

// optional attributes
const EnumTestO = t.partial({
  status: enumType<StatusEnum>(StatusEnum, \\"status\\")
});

export const EnumTest = t.intersection([EnumTestR, EnumTestO], \\"EnumTest\\");

export type EnumTest = t.TypeOf<typeof EnumTest>;
"
`;

exports[`gen-api-models should include aliases for types already defined elsewhere if they have a different name: defined-type 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { OrganizationFiscalCode as OrganizationFiscalCodeT } from \\"italia-ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type OrganizationFiscalCodeTest = t.TypeOf<
  typeof OrganizationFiscalCodeTest
>;
export const OrganizationFiscalCodeTest = OrganizationFiscalCodeT;
"
`;

exports[`gen-api-models should not generate duplicate imports: dup-imports 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import { EmailAddress } from \\"./EmailAddress\\";
import { FiscalCode } from \\"./FiscalCode\\";
import { IsInboxEnabled } from \\"./IsInboxEnabled\\";
import { IsWebhookEnabled } from \\"./IsWebhookEnabled\\";
import { PreferredLanguages } from \\"./PreferredLanguages\\";
import * as t from \\"io-ts\\";

/**
 * Describes the user's profile.
 */

// required attributes
const ProfilePayloadR = t.interface({});

// optional attributes
const ProfilePayloadO = t.partial({});

export const ProfilePayload = t.intersection(
  [ProfilePayloadR, ProfilePayloadO],
  \\"ProfilePayload\\"
);

export type ProfilePayload = t.TypeOf<typeof ProfilePayload>;

// required attributes
const ProfileR = t.interface({
  family_name: t.string,

  fiscal_code: FiscalCode,

  has_profile: t.boolean,

  is_email_set: t.boolean,

  name: t.string,

  version: t.Integer
});

// optional attributes
const ProfileO = t.partial({
  email: EmailAddress,

  is_inbox_enabled: IsInboxEnabled,

  is_webhook_enabled: IsWebhookEnabled,

  preferred_email: EmailAddress,

  preferred_languages: PreferredLanguages,

  payload: ProfilePayload
});

export const Profile = t.intersection([ProfileR, ProfileO], \\"Profile\\");

export type Profile = t.TypeOf<typeof Profile>;
"
`;

exports[`gen-api-models should parse custom inline properties: inline-property 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { PatternString } from \\"italia-ts-commons/lib/strings\\";

// required attributes
const InlinePropertyTestR = t.interface({});

// optional attributes
const InlinePropertyTestO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  )
});

export const InlinePropertyTest = t.intersection(
  [InlinePropertyTestR, InlinePropertyTestO],
  \\"InlinePropertyTest\\"
);

export type InlinePropertyTest = t.TypeOf<typeof InlinePropertyTest>;
"
`;

exports[`gen-api-models should parse nested objects: nested-object 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { PatternString } from \\"italia-ts-commons/lib/strings\\";

// required attributes
const NestedObjectTestNestedObjectR = t.interface({});

// optional attributes
const NestedObjectTestNestedObjectO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  )
});

export const NestedObjectTestNestedObject = t.intersection(
  [NestedObjectTestNestedObjectR, NestedObjectTestNestedObjectO],
  \\"NestedObjectTestNestedObject\\"
);

export type NestedObjectTestNestedObject = t.TypeOf<
  typeof NestedObjectTestNestedObject
>;

// required attributes
const NestedObjectTestR = t.interface({});

// optional attributes
const NestedObjectTestO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  ),

  nestedObject: NestedObjectTestNestedObject
});

export const NestedObjectTest = t.intersection(
  [NestedObjectTestR, NestedObjectTestO],
  \\"NestedObjectTest\\"
);

export type NestedObjectTest = t.TypeOf<typeof NestedObjectTest>;
"
`;

exports[`gen-api-models should render a client 1`] = `
"/**
 * Do not edit this file it is auto-generated by italia-utils / gen-api-models.
 * See https://github.com/teamdigitale/italia-utils
 */
/* tslint:disable */

import {
  ApiHeaderJson,
  RequestParams,
  TypeofApiCall,
  composeHeaderProducers,
  createFetchRequestForApi,
  RequestHeaderProducer,
  RequestHeaderKey,
  ReplaceRequestParams
} from \\"italia-ts-commons/lib/requests\\";

import {
  TestAuthBearerT,
  testAuthBearerDefaultDecoder,
  TestMultipleSuccessT,
  testMultipleSuccessDefaultDecoder,
  TestFileUploadT,
  testFileUploadDefaultDecoder
} from \\"./requestTypes\\";

export function Client(
  baseUrl: string,
  // tslint:disable-next-line:no-any
  fetchApi: typeof fetch,
  basePath: string = \\"/api/v1\\"
): {
  readonly testAuthBearer: TypeofApiCall<typeof testAuthBearerT>;
  readonly testMultipleSuccess: TypeofApiCall<typeof testMultipleSuccessT>;
  readonly testFileUpload: TypeofApiCall<typeof testFileUploadT>;
} {
  const options = {
    baseUrl,
    fetchApi
  };

  const testAuthBearerT: ReplaceRequestParams<
    TestAuthBearerT,
    RequestParams<TestAuthBearerT>
  > = {
    method: \\"get\\",

    headers: ({ bearerToken }: { bearerToken: string }) => ({
      Authorization: \`Bearer \${bearerToken}\`
    }),

    response_decoder: testAuthBearerDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-auth-bearer\`,

    query: ({ qo, qr, cursor }) => ({ qo, qr, cursor })
  };
  const testAuthBearer = createFetchRequestForApi(testAuthBearerT, options);

  const testMultipleSuccessT: ReplaceRequestParams<
    TestMultipleSuccessT,
    RequestParams<TestMultipleSuccessT>
  > = {
    method: \\"get\\",

    headers: () => ({}),

    response_decoder: testMultipleSuccessDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-multiple-success\`,

    query: () => ({})
  };
  const testMultipleSuccess = createFetchRequestForApi(
    testMultipleSuccessT,
    options
  );

  const testFileUploadT: ReplaceRequestParams<
    TestFileUploadT,
    RequestParams<TestFileUploadT>
  > = {
    method: \\"post\\",

    headers: () => ({ \\"Content-Type\\": \\"multipart/form-data\\" }),

    response_decoder: testFileUploadDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-file-upload\`,

    body: ({ file }) => file.uri,

    query: () => ({})
  };
  const testFileUpload = createFetchRequestForApi(testFileUploadT, options);

  return {
    testAuthBearer,
    testMultipleSuccess,
    testFileUpload
  };
}

export type Client = typeof Client;
"
`;

exports[`gen-api-models should support additionalProperties default value: additional-properties-default 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* tslint:disable */

import * as t from \\"io-ts\\";
import { withDefault } from \\"italia-ts-commons/lib/types\\";

type AdditionalpropsDefaultBase = t.TypeOf<typeof AdditionalpropsDefaultBase>;
const AdditionalpropsDefaultBase = t.dictionary(
  t.string,

  t.readonlyArray(t.number, \\"array of number\\"),

  \\"AdditionalpropsDefault\\"
);

// additional attributes

export const AdditionalpropsDefault = withDefault(AdditionalpropsDefaultBase, {
  test: [1000]
} as AdditionalpropsDefaultBase);

export type AdditionalpropsDefault = t.TypeOf<typeof AdditionalpropsDefault>;
"
`;

exports[`gen-api-models should support file uploads 1`] = `
"
    /****************************************************************
     * testFileUpload
     */

    // Request type definition
    export type TestFileUploadT = r.IPostApiRequestType<{readonly file: { uri: string, name: string, type: string }}, \\"Content-Type\\", never, r.IResponseType<200, undefined>>;
  
      
    export const testFileUploadDefaultResponses = {
      200: t.undefined
    };
  
      
    export type TestFileUploadResponsesT<A0 = undefined, C0 = undefined> = {
      200: t.Type<A0, C0>
    };
  
      export function testFileUploadDecoder<A0 = undefined, C0 = undefined>(overrideTypes: Partial<TestFileUploadResponsesT<A0, C0>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testFileUploadDefaultResponses as unknown as TestFileUploadResponsesT<A0, C0>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
    const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"]>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
  
        return d200
      }

      // Decodes the success response with the type defined in the specs
      export const testFileUploadDefaultDecoder = () => testFileUploadDecoder();"
`;

exports[`gen-api-models should support multiple success cases 1`] = `
"
    /****************************************************************
     * testMultipleSuccess
     */

    // Request type definition
    export type TestMultipleSuccessT = r.IGetApiRequestType<{}, never, never, r.IResponseType<200, Message>|r.IResponseType<202, undefined>|r.IResponseType<403, OneOfTest>|r.IResponseType<404, undefined>>;
  
      
    export const testMultipleSuccessDefaultResponses = {
      200: Message, 202: t.undefined, 403: OneOfTest, 404: t.undefined
    };
  
      
    export type TestMultipleSuccessResponsesT<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined, A2 = OneOfTest, C2 = OneOfTest, A3 = undefined, C3 = undefined> = {
      200: t.Type<A0, C0>, 202: t.Type<A1, C1>, 403: t.Type<A2, C2>, 404: t.Type<A3, C3>
    };
  
      export function testMultipleSuccessDecoder<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined, A2 = OneOfTest, C2 = OneOfTest, A3 = undefined, C3 = undefined>(overrideTypes: Partial<TestMultipleSuccessResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<202, A1, never>|r.IResponseType<403, A2, never>|r.IResponseType<404, A3, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testMultipleSuccessDefaultResponses as unknown as TestMultipleSuccessResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
    const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"]>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
  
    const d202 = (type[202].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 202>(202, undefined) 
        : r.ioResponseDecoder<202, (typeof type[202])[\\"_A\\"], (typeof type[202])[\\"_O\\"]>(202, type[202])) as r.ResponseDecoder<r.IResponseType<202, A1, never>>;
  
    const d403 = (type[403].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 403>(403, undefined) 
        : r.ioResponseDecoder<403, (typeof type[403])[\\"_A\\"], (typeof type[403])[\\"_O\\"]>(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A2, never>>;
  
    const d404 = (type[404].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 404>(404, undefined) 
        : r.ioResponseDecoder<404, (typeof type[404])[\\"_A\\"], (typeof type[404])[\\"_O\\"]>(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;
  
        return r.composeResponseDecoders(r.composeResponseDecoders(r.composeResponseDecoders(d200, d202), d403), d404)
      }

      // Decodes the success response with the type defined in the specs
      export const testMultipleSuccessDefaultDecoder = () => testMultipleSuccessDecoder();"
`;
