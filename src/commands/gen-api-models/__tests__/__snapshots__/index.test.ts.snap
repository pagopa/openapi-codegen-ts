// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`gen-api-models should generate a dictionary from additionalProperties: additional-properties 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";

// additional attributes

export const AdditionalPropsTest = t.dictionary(
  t.string,

  t.readonlyArray(t.number, \\"array of number\\"),

  \\"AdditionalPropsTest\\"
);

export type AdditionalPropsTest = t.TypeOf<typeof AdditionalPropsTest>;
"
`;

exports[`gen-api-models should generate a dictionary from additionalProperties: true: additional-properties-true 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";

// additional attributes

export const AdditionalPropsTrueTest = t.dictionary(
  t.string,
  t.any,
  \\"AdditionalPropsTrueTest\\"
);

export type AdditionalPropsTrueTest = t.TypeOf<typeof AdditionalPropsTrueTest>;
"
`;

exports[`gen-api-models should generate a module with all definitions 1`] = `
"// DO NOT EDIT THIS FILE
// This file has been generated by gen-api-models
// eslint-disable sonar/max-union-size
// eslint-disable sonarjs/no-identical-functions

import * as t from \\"io-ts\\";

import * as r from \\"@pagopa/ts-commons/lib/requests\\";

/****************************************************************
 * testAuthBearer
 */

// Request type definition
export type TestAuthBearerT = r.IGetApiRequestType<
  {
    readonly bearerToken: string;
    readonly qo?: string;
    readonly qr: string;
    readonly cursor?: string;
  },
  \\"Authorization\\",
  never,
  | r.IResponseType<200, undefined, never>
  | r.IResponseType<403, undefined, never>
>;

export const testAuthBearerDefaultResponses = {
  200: t.undefined,
  403: t.undefined
};

export type TestAuthBearerResponsesT<
  A0 = undefined,
  C0 = undefined,
  A1 = undefined,
  C1 = undefined
> = {
  200: t.Type<A0, C0>;
  403: t.Type<A1, C1>;
};

export function testAuthBearerDecoder<
  A0 = undefined,
  C0 = undefined,
  A1 = undefined,
  C1 = undefined
>(
  overrideTypes:
    | Partial<TestAuthBearerResponsesT<A0, C0, A1, C1>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<
  r.IResponseType<200, A0, never> | r.IResponseType<403, A1, never>
> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d[\\"_A\\"] !== \\"undefined\\";

  const type = {
    ...((testAuthBearerDefaultResponses as unknown) as TestAuthBearerResponsesT<
      A0,
      C0,
      A1,
      C1
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === \\"undefined\\"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200][\\"_A\\"],
        typeof type[200][\\"_O\\"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  const d403 = (type[403].name === \\"undefined\\"
    ? r.constantResponseDecoder<undefined, 403, never>(403, undefined)
    : r.ioResponseDecoder<
        403,
        typeof type[403][\\"_A\\"],
        typeof type[403][\\"_O\\"],
        never
      >(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A1, never>>;

  return r.composeResponseDecoders(d200, d403);
}

// Decodes the success response with the type defined in the specs
export const testAuthBearerDefaultDecoder = () => testAuthBearerDecoder();

/****************************************************************
 * testFileUpload
 */

// Request type definition
export type TestFileUploadT = r.IPostApiRequestType<
  { readonly file: { uri: string; name: string; type: string } },
  \\"Content-Type\\",
  never,
  r.IResponseType<200, undefined, never>
>;

export const testFileUploadDefaultResponses = {
  200: t.undefined
};

export type TestFileUploadResponsesT<A0 = undefined, C0 = undefined> = {
  200: t.Type<A0, C0>;
};

export function testFileUploadDecoder<A0 = undefined, C0 = undefined>(
  overrideTypes:
    | Partial<TestFileUploadResponsesT<A0, C0>>
    | t.Type<A0, C0>
    | undefined = {}
): r.ResponseDecoder<r.IResponseType<200, A0, never>> {
  const isDecoder = (d: any): d is t.Type<A0, C0> =>
    typeof d[\\"_A\\"] !== \\"undefined\\";

  const type = {
    ...((testFileUploadDefaultResponses as unknown) as TestFileUploadResponsesT<
      A0,
      C0
    >),
    ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
  };

  const d200 = (type[200].name === \\"undefined\\"
    ? r.constantResponseDecoder<undefined, 200, never>(200, undefined)
    : r.ioResponseDecoder<
        200,
        typeof type[200][\\"_A\\"],
        typeof type[200][\\"_O\\"],
        never
      >(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;

  return d200;
}

// Decodes the success response with the type defined in the specs
export const testFileUploadDefaultDecoder = () => testFileUploadDecoder();
"
`;

exports[`gen-api-models should generate a type intersection from allOf: all-of-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";
import { Message } from \\"./Message\\";
import { PaginationResponse } from \\"./PaginationResponse\\";

// required attributes
const AllOfTest1R = t.interface({});

// optional attributes
const AllOfTest1O = t.partial({
  items: t.readonlyArray(Message, \\"array of Message\\")
});

export const AllOfTest1 = t.intersection(
  [AllOfTest1R, AllOfTest1O],
  \\"AllOfTest1\\"
);

export type AllOfTest1 = t.TypeOf<typeof AllOfTest1>;

export const AllOfTest = t.intersection(
  [AllOfTest1, PaginationResponse],
  \\"AllOfTest\\"
);

export type AllOfTest = t.TypeOf<typeof AllOfTest>;
"
`;

exports[`gen-api-models should generate a type union from allOf when x-one-of is used: allofoneof-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";
import { Message } from \\"./Message\\";
import { PaginationResponse } from \\"./PaginationResponse\\";

/**
 * test if we can use allOf as oneOf
 */

// required attributes
const AllOfOneOfTest1R = t.interface({});

// optional attributes
const AllOfOneOfTest1O = t.partial({
  items: t.readonlyArray(Message, \\"array of Message\\")
});

export const AllOfOneOfTest1 = t.intersection(
  [AllOfOneOfTest1R, AllOfOneOfTest1O],
  \\"AllOfOneOfTest1\\"
);

export type AllOfOneOfTest1 = t.TypeOf<typeof AllOfOneOfTest1>;

export const AllOfOneOfTest = t.union(
  [AllOfOneOfTest1, PaginationResponse],
  \\"AllOfOneOfTest\\"
);

export type AllOfOneOfTest = t.TypeOf<typeof AllOfOneOfTest>;
"
`;

exports[`gen-api-models should generate a type union from oneOf: oneof-test 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";

// required attributes
const OneOfTest1R = t.interface({});

// optional attributes
const OneOfTest1O = t.partial({
  limited: t.boolean
});

export const OneOfTest1 = t.intersection(
  [OneOfTest1R, OneOfTest1O],
  \\"OneOfTest1\\"
);

export type OneOfTest1 = t.TypeOf<typeof OneOfTest1>;

// required attributes
const OneOfTest2R = t.interface({});

// optional attributes
const OneOfTest2O = t.partial({
  unlimited: t.boolean
});

export const OneOfTest2 = t.intersection(
  [OneOfTest2R, OneOfTest2O],
  \\"OneOfTest2\\"
);

export type OneOfTest2 = t.TypeOf<typeof OneOfTest2>;

export const OneOfTest = t.union([OneOfTest1, OneOfTest2], \\"OneOfTest\\");

export type OneOfTest = t.TypeOf<typeof OneOfTest>;
"
`;

exports[`gen-api-models should generate decoder definitions for (get, /test-auth-bearer)  1`] = `
"
    /****************************************************************
     * testAuthBearer
     */

    // Request type definition
    export type TestAuthBearerT = r.IGetApiRequestType<{readonly \\"bearerToken\\": string,readonly \\"qo\\"?: string,readonly \\"qr\\": string,readonly \\"cursor\\"?: string}, \\"Authorization\\", never, r.IResponseType<200, undefined, never>|r.IResponseType<403, undefined, never>>;
  
      
    export const testAuthBearerDefaultResponses = {
      200: t.undefined, 403: t.undefined
    };
  
      
    export type TestAuthBearerResponsesT<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined> = {
      200: t.Type<A0, C0>, 403: t.Type<A1, C1>
    };
  
      export function testAuthBearerDecoder<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined>(overrideTypes: Partial<TestAuthBearerResponsesT<A0, C0, A1, C1>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<403, A1, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testAuthBearerDefaultResponses as unknown as TestAuthBearerResponsesT<A0, C0, A1, C1>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
        const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
      
        const d403 = (type[403].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 403, never>(403, undefined) 
        : r.ioResponseDecoder<403, (typeof type[403])[\\"_A\\"], (typeof type[403])[\\"_O\\"], never>(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A1, never>>;
      
        return r.composeResponseDecoders(d200, d403)
      }

      // Decodes the success response with the type defined in the specs
      export const testAuthBearerDefaultDecoder = () => testAuthBearerDecoder();"
`;

exports[`gen-api-models should generate decoder definitions for (get, /test-parameter-with-dash/{path-param})  1`] = `
"
    /****************************************************************
     * testParameterWithDash
     */

    // Request type definition
    export type TestParameterWithDashT = r.IGetApiRequestType<{readonly \\"path-param\\"?: string,readonly \\"foo-bar\\"?: string,readonly \\"headerInlineParam\\": string,readonly \\"request-id\\"?: string,readonly \\"x-header-param\\": string}, never, never, r.IResponseType<200, undefined, never>|r.IResponseType<500, undefined, never>>;
  
      
    export const testParameterWithDashDefaultResponses = {
      200: t.undefined, 500: t.undefined
    };
  
      
    export type TestParameterWithDashResponsesT<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined> = {
      200: t.Type<A0, C0>, 500: t.Type<A1, C1>
    };
  
      export function testParameterWithDashDecoder<A0 = undefined, C0 = undefined, A1 = undefined, C1 = undefined>(overrideTypes: Partial<TestParameterWithDashResponsesT<A0, C0, A1, C1>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<500, A1, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testParameterWithDashDefaultResponses as unknown as TestParameterWithDashResponsesT<A0, C0, A1, C1>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
        const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
      
        const d500 = (type[500].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 500, never>(500, undefined) 
        : r.ioResponseDecoder<500, (typeof type[500])[\\"_A\\"], (typeof type[500])[\\"_O\\"], never>(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A1, never>>;
      
        return r.composeResponseDecoders(d200, d500)
      }

      // Decodes the success response with the type defined in the specs
      export const testParameterWithDashDefaultDecoder = () => testParameterWithDashDecoder();"
`;

exports[`gen-api-models should handle CustomStringFormats: custom-string-format 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import { SomeCustomStringType as SomeCustomStringTypeT } from \\"@pagopa/ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type CustomStringFormatTest = t.TypeOf<typeof CustomStringFormatTest>;
export const CustomStringFormatTest = SomeCustomStringTypeT;
"
`;

exports[`gen-api-models should handle NonNegativeIntegers: non-negative-integer 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import { NonNegativeInteger } from \\"@pagopa/ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type NonNegativeIntegerTest = t.TypeOf<typeof NonNegativeIntegerTest>;
export const NonNegativeIntegerTest = NonNegativeInteger;
"
`;

exports[`gen-api-models should handle NonNegativeNumbers: non-negative-numbers 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import { NonNegativeNumber } from \\"@pagopa/ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type NonNegativeNumberTest = t.TypeOf<typeof NonNegativeNumberTest>;
export const NonNegativeNumberTest = NonNegativeNumber;
"
`;

exports[`gen-api-models should handle WithinRangeIntegers: within-range-integer 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import {
  IWithinRangeIntegerTag,
  WithinRangeInteger
} from \\"@pagopa/ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type WithinRangeIntegerTest = t.TypeOf<typeof WithinRangeIntegerTest>;
export const WithinRangeIntegerTest = t.union([
  WithinRangeInteger<0, 10, IWithinRangeIntegerTag<0, 10>>(0, 10),
  t.literal(10)
]);
"
`;

exports[`gen-api-models should handle WithinRangeNumbers: within-range-numbers 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import {
  IWithinRangeNumberTag,
  WithinRangeNumber
} from \\"@pagopa/ts-commons/lib/numbers\\";
import * as t from \\"io-ts\\";

export type WithinRangeNumberTest = t.TypeOf<typeof WithinRangeNumberTest>;
export const WithinRangeNumberTest = t.union([
  WithinRangeNumber<0, 10, IWithinRangeNumberTag<0, 10>>(0, 10),
  t.literal(10)
]);
"
`;

exports[`gen-api-models should handle WithinRangeStrings: within-range-strings 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import { WithinRangeString } from \\"@pagopa/ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type WithinRangeStringTest = t.TypeOf<typeof WithinRangeStringTest>;
export const WithinRangeStringTest = WithinRangeString(8, 11);
"
`;

exports[`gen-api-models should handle enums: enum-simple 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";
import { enumType } from \\"@pagopa/ts-commons/lib/types\\";

export enum StatusEnum {
  \\"value1\\" = \\"value1\\",

  \\"value2\\" = \\"value2\\",

  \\"value3\\" = \\"value3\\"
}

// required attributes
const EnumTestR = t.interface({});

// optional attributes
const EnumTestO = t.partial({
  status: enumType<StatusEnum>(StatusEnum, \\"status\\")
});

export const EnumTest = t.intersection([EnumTestR, EnumTestO], \\"EnumTest\\");

export type EnumTest = t.TypeOf<typeof EnumTest>;
"
`;

exports[`gen-api-models should include aliases for types already defined elsewhere if they have a different name: defined-type 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import { OrganizationFiscalCode as OrganizationFiscalCodeT } from \\"@pagopa/ts-commons/lib/strings\\";
import * as t from \\"io-ts\\";

export type OrganizationFiscalCodeTest = t.TypeOf<
  typeof OrganizationFiscalCodeTest
>;
export const OrganizationFiscalCodeTest = OrganizationFiscalCodeT;
"
`;

exports[`gen-api-models should not generate duplicate imports: dup-imports 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import { EmailAddress } from \\"./EmailAddress\\";
import { FiscalCode } from \\"./FiscalCode\\";
import { IsInboxEnabled } from \\"./IsInboxEnabled\\";
import { IsWebhookEnabled } from \\"./IsWebhookEnabled\\";
import { PreferredLanguages } from \\"./PreferredLanguages\\";
import * as t from \\"io-ts\\";

/**
 * Describes the user's profile.
 */

// required attributes
const ProfilePayloadR = t.interface({});

// optional attributes
const ProfilePayloadO = t.partial({});

export const ProfilePayload = t.intersection(
  [ProfilePayloadR, ProfilePayloadO],
  \\"ProfilePayload\\"
);

export type ProfilePayload = t.TypeOf<typeof ProfilePayload>;

// required attributes
const ProfileR = t.interface({
  family_name: t.string,

  fiscal_code: FiscalCode,

  has_profile: t.boolean,

  is_email_set: t.boolean,

  name: t.string,

  version: t.Integer
});

// optional attributes
const ProfileO = t.partial({
  email: EmailAddress,

  is_inbox_enabled: IsInboxEnabled,

  is_webhook_enabled: IsWebhookEnabled,

  preferred_email: EmailAddress,

  preferred_languages: PreferredLanguages,

  payload: ProfilePayload
});

export const Profile = t.intersection([ProfileR, ProfileO], \\"Profile\\");

export type Profile = t.TypeOf<typeof Profile>;
"
`;

exports[`gen-api-models should parse custom inline properties: inline-property 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";
import { PatternString } from \\"@pagopa/ts-commons/lib/strings\\";

// required attributes
const InlinePropertyTestR = t.interface({});

// optional attributes
const InlinePropertyTestO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  )
});

export const InlinePropertyTest = t.intersection(
  [InlinePropertyTestR, InlinePropertyTestO],
  \\"InlinePropertyTest\\"
);

export type InlinePropertyTest = t.TypeOf<typeof InlinePropertyTest>;
"
`;

exports[`gen-api-models should parse nested objects: nested-object 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";
import { PatternString } from \\"@pagopa/ts-commons/lib/strings\\";

// required attributes
const NestedObjectTestNestedObjectR = t.interface({});

// optional attributes
const NestedObjectTestNestedObjectO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  )
});

export const NestedObjectTestNestedObject = t.intersection(
  [NestedObjectTestNestedObjectR, NestedObjectTestNestedObjectO],
  \\"NestedObjectTestNestedObject\\"
);

export type NestedObjectTestNestedObject = t.TypeOf<
  typeof NestedObjectTestNestedObject
>;

// required attributes
const NestedObjectTestR = t.interface({});

// optional attributes
const NestedObjectTestO = t.partial({
  inlineProp: PatternString(
    \\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\\"
  ),

  nestedObject: NestedObjectTestNestedObject
});

export const NestedObjectTest = t.intersection(
  [NestedObjectTestR, NestedObjectTestO],
  \\"NestedObjectTest\\"
);

export type NestedObjectTest = t.TypeOf<typeof NestedObjectTest>;
"
`;

exports[`gen-api-models should render a client 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import {
  RequestParams,
  TypeofApiCall,
  TypeofApiParams,
  createFetchRequestForApi,
  ReplaceRequestParams
} from \\"@pagopa/ts-commons/lib/requests\\";
import { identity } from \\"fp-ts/lib/function\\";

import {
  TestAuthBearerT,
  testAuthBearerDefaultDecoder,
  TestSimpleTokenT,
  testSimpleTokenDefaultDecoder,
  TestMultipleSuccessT,
  testMultipleSuccessDefaultDecoder,
  TestFileUploadT,
  testFileUploadDefaultDecoder,
  TestResponseHeaderT,
  testResponseHeaderDefaultDecoder,
  TestParameterWithReferenceT,
  testParameterWithReferenceDefaultDecoder,
  TestParameterWithDashT,
  testParameterWithDashDefaultDecoder,
  TestParameterWithDashAnUnderscoreT,
  testParameterWithDashAnUnderscoreDefaultDecoder,
  TestWithTwoParamsT,
  testWithTwoParamsDefaultDecoder
} from \\"./requestTypes\\";

// This is a placeholder for undefined when dealing with object keys
// Typescript doesn't perform well when narrowing a union type which includes string and undefined
// (example: \\"foo\\" | \\"bar\\" | undefined)
// We use this as a placeholder for type parameters indicating \\"no key\\"
type __UNDEFINED_KEY = \\"_____\\";

export type ApiOperation = TypeofApiCall<TestAuthBearerT> &
  TypeofApiCall<TestSimpleTokenT> &
  TypeofApiCall<TestMultipleSuccessT> &
  TypeofApiCall<TestFileUploadT> &
  TypeofApiCall<TestResponseHeaderT> &
  TypeofApiCall<TestParameterWithReferenceT> &
  TypeofApiCall<TestParameterWithDashT> &
  TypeofApiCall<TestParameterWithDashAnUnderscoreT> &
  TypeofApiCall<TestWithTwoParamsT>;

export type ParamKeys = keyof (TypeofApiParams<TestAuthBearerT> &
  TypeofApiParams<TestSimpleTokenT> &
  TypeofApiParams<TestMultipleSuccessT> &
  TypeofApiParams<TestFileUploadT> &
  TypeofApiParams<TestResponseHeaderT> &
  TypeofApiParams<TestParameterWithReferenceT> &
  TypeofApiParams<TestParameterWithDashT> &
  TypeofApiParams<TestParameterWithDashAnUnderscoreT> &
  TypeofApiParams<TestWithTwoParamsT>);

/**
 * Defines an adapter for TypeofApiCall which omit one or more parameters in the signature
 * @param ApiT the type which defines the operation to expose
 * @param K the parameter to omit. undefined means no parameters will be omitted
 */
export type OmitApiCallParams<
  ApiT,
  K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = (
  op: TypeofApiCall<ApiT>
) => K extends __UNDEFINED_KEY
  ? TypeofApiCall<ApiT>
  : TypeofApiCall<ReplaceRequestParams<ApiT, Omit<RequestParams<ApiT>, K>>>;

/**
 * Defines an adapter for TypeofApiCall which omit one or more parameters in the signature
 * @param ApiT the type which defines the operation to expose
 * @param K the parameter to omit. undefined means no parameters will be omitted
 */
export type WithDefaultsT<
  K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = OmitApiCallParams<
  | TestAuthBearerT
  | TestSimpleTokenT
  | TestMultipleSuccessT
  | TestFileUploadT
  | TestResponseHeaderT
  | TestParameterWithReferenceT
  | TestParameterWithDashT
  | TestParameterWithDashAnUnderscoreT
  | TestWithTwoParamsT,
  K
>;

/**
 * Defines a collection of api operations
 * @param K name of the parameters that the Clients masks from the operations
 */
export type Client<
  K extends ParamKeys | __UNDEFINED_KEY = __UNDEFINED_KEY
> = K extends __UNDEFINED_KEY
  ? {
      readonly testAuthBearer: TypeofApiCall<TestAuthBearerT>;

      readonly testSimpleToken: TypeofApiCall<TestSimpleTokenT>;

      readonly testMultipleSuccess: TypeofApiCall<TestMultipleSuccessT>;

      readonly testFileUpload: TypeofApiCall<TestFileUploadT>;

      readonly testResponseHeader: TypeofApiCall<TestResponseHeaderT>;

      readonly testParameterWithReference: TypeofApiCall<
        TestParameterWithReferenceT
      >;

      readonly testParameterWithDash: TypeofApiCall<TestParameterWithDashT>;

      readonly testParameterWithDashAnUnderscore: TypeofApiCall<
        TestParameterWithDashAnUnderscoreT
      >;

      readonly testWithTwoParams: TypeofApiCall<TestWithTwoParamsT>;
    }
  : {
      readonly testAuthBearer: TypeofApiCall<
        ReplaceRequestParams<
          TestAuthBearerT,
          Omit<RequestParams<TestAuthBearerT>, K>
        >
      >;

      readonly testSimpleToken: TypeofApiCall<
        ReplaceRequestParams<
          TestSimpleTokenT,
          Omit<RequestParams<TestSimpleTokenT>, K>
        >
      >;

      readonly testMultipleSuccess: TypeofApiCall<
        ReplaceRequestParams<
          TestMultipleSuccessT,
          Omit<RequestParams<TestMultipleSuccessT>, K>
        >
      >;

      readonly testFileUpload: TypeofApiCall<
        ReplaceRequestParams<
          TestFileUploadT,
          Omit<RequestParams<TestFileUploadT>, K>
        >
      >;

      readonly testResponseHeader: TypeofApiCall<
        ReplaceRequestParams<
          TestResponseHeaderT,
          Omit<RequestParams<TestResponseHeaderT>, K>
        >
      >;

      readonly testParameterWithReference: TypeofApiCall<
        ReplaceRequestParams<
          TestParameterWithReferenceT,
          Omit<RequestParams<TestParameterWithReferenceT>, K>
        >
      >;

      readonly testParameterWithDash: TypeofApiCall<
        ReplaceRequestParams<
          TestParameterWithDashT,
          Omit<RequestParams<TestParameterWithDashT>, K>
        >
      >;

      readonly testParameterWithDashAnUnderscore: TypeofApiCall<
        ReplaceRequestParams<
          TestParameterWithDashAnUnderscoreT,
          Omit<RequestParams<TestParameterWithDashAnUnderscoreT>, K>
        >
      >;

      readonly testWithTwoParams: TypeofApiCall<
        ReplaceRequestParams<
          TestWithTwoParamsT,
          Omit<RequestParams<TestWithTwoParamsT>, K>
        >
      >;
    };

/**
 * Create an instance of a client
 * @param params hash map of parameters thata define the client:
 *  - baseUrl: the base url for every api call (required)
 *  - fetchApi: an implementation of the fetch() web API, depending on the platform (required)
 *  - basePath: optional path to be appended to the baseUrl
 *  - withDefaults: optional adapter to be applied to every operation, to omit some paramenters
 * @returns a collection of api operations
 */
export function createClient<K extends ParamKeys>(params: {
  baseUrl: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fetchApi: typeof fetch;
  withDefaults: WithDefaultsT<K>;
  basePath?: string;
}): Client<K>;
export function createClient(params: {
  baseUrl: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fetchApi: typeof fetch;
  withDefaults?: undefined;
  basePath?: string;
}): Client;
export function createClient<K extends ParamKeys>({
  baseUrl,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fetchApi,
  withDefaults,
  basePath = \\"/api/v1\\"
}: {
  baseUrl: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  fetchApi: typeof fetch;
  withDefaults?: WithDefaultsT<K>;
  basePath?: string;
}) {
  const options = {
    baseUrl,
    fetchApi
  };

  const testAuthBearerT: ReplaceRequestParams<
    TestAuthBearerT,
    RequestParams<TestAuthBearerT>
  > = {
    method: \\"get\\",

    headers: ({ [\\"bearerToken\\"]: bearerToken }: { bearerToken: string }) => ({
      Authorization: \`Bearer \${bearerToken}\`
    }),
    response_decoder: testAuthBearerDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-auth-bearer\`,

    query: ({ [\\"qo\\"]: qo, [\\"qr\\"]: qr, [\\"cursor\\"]: cursor }) => ({
      [\\"qo\\"]: qo,
      [\\"qr\\"]: qr,
      [\\"cursor\\"]: cursor
    })
  };
  const testAuthBearer: TypeofApiCall<TestAuthBearerT> = createFetchRequestForApi(
    testAuthBearerT,
    options
  );

  const testSimpleTokenT: ReplaceRequestParams<
    TestSimpleTokenT,
    RequestParams<TestSimpleTokenT>
  > = {
    method: \\"get\\",

    headers: ({ [\\"simpleToken\\"]: simpleToken }: { simpleToken: string }) => ({
      \\"X-Functions-Key\\": simpleToken
    }),
    response_decoder: testSimpleTokenDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-simple-token\`,

    query: ({ [\\"qo\\"]: qo, [\\"qr\\"]: qr, [\\"cursor\\"]: cursor }) => ({
      [\\"qo\\"]: qo,
      [\\"qr\\"]: qr,
      [\\"cursor\\"]: cursor
    })
  };
  const testSimpleToken: TypeofApiCall<TestSimpleTokenT> = createFetchRequestForApi(
    testSimpleTokenT,
    options
  );

  const testMultipleSuccessT: ReplaceRequestParams<
    TestMultipleSuccessT,
    RequestParams<TestMultipleSuccessT>
  > = {
    method: \\"get\\",

    headers: () => ({}),

    response_decoder: testMultipleSuccessDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-multiple-success\`,

    query: () => ({})
  };
  const testMultipleSuccess: TypeofApiCall<TestMultipleSuccessT> = createFetchRequestForApi(
    testMultipleSuccessT,
    options
  );

  const testFileUploadT: ReplaceRequestParams<
    TestFileUploadT,
    RequestParams<TestFileUploadT>
  > = {
    method: \\"post\\",

    headers: () => ({
      \\"Content-Type\\": \\"multipart/form-data\\"
    }),
    response_decoder: testFileUploadDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-file-upload\`,

    body: ({ [\\"file\\"]: file }) => file.uri,

    query: () => ({})
  };
  const testFileUpload: TypeofApiCall<TestFileUploadT> = createFetchRequestForApi(
    testFileUploadT,
    options
  );

  const testResponseHeaderT: ReplaceRequestParams<
    TestResponseHeaderT,
    RequestParams<TestResponseHeaderT>
  > = {
    method: \\"get\\",

    headers: () => ({}),

    response_decoder: testResponseHeaderDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-response-header\`,

    query: () => ({})
  };
  const testResponseHeader: TypeofApiCall<TestResponseHeaderT> = createFetchRequestForApi(
    testResponseHeaderT,
    options
  );

  const testParameterWithReferenceT: ReplaceRequestParams<
    TestParameterWithReferenceT,
    RequestParams<TestParameterWithReferenceT>
  > = {
    method: \\"post\\",

    headers: () => ({
      \\"Content-Type\\": \\"application/json\\"
    }),
    response_decoder: testParameterWithReferenceDefaultDecoder(),
    url: ({}) => \`\${basePath}/test-parameter-with-reference\`,

    body: ({ [\\"createdMessage\\"]: createdMessage }) =>
      JSON.stringify(createdMessage),

    query: () => ({})
  };
  const testParameterWithReference: TypeofApiCall<TestParameterWithReferenceT> = createFetchRequestForApi(
    testParameterWithReferenceT,
    options
  );

  const testParameterWithDashT: ReplaceRequestParams<
    TestParameterWithDashT,
    RequestParams<TestParameterWithDashT>
  > = {
    method: \\"get\\",

    headers: ({
      [\\"headerInlineParam\\"]: headerInlineParam,
      [\\"x-header-param\\"]: xHeaderParam
    }: {
      headerInlineParam: string;
      \\"x-header-param\\": string;
    }) => ({
      headerInlineParam: headerInlineParam,

      \\"x-header-param\\": xHeaderParam
    }),
    response_decoder: testParameterWithDashDefaultDecoder(),
    url: ({ [\\"path-param\\"]: pathParam }) =>
      \`\${basePath}/test-parameter-with-dash/\${pathParam}\`,

    query: ({ [\\"foo-bar\\"]: fooBar, [\\"request-id\\"]: requestId }) => ({
      [\\"foo-bar\\"]: fooBar,
      [\\"request-id\\"]: requestId
    })
  };
  const testParameterWithDash: TypeofApiCall<TestParameterWithDashT> = createFetchRequestForApi(
    testParameterWithDashT,
    options
  );

  const testParameterWithDashAnUnderscoreT: ReplaceRequestParams<
    TestParameterWithDashAnUnderscoreT,
    RequestParams<TestParameterWithDashAnUnderscoreT>
  > = {
    method: \\"get\\",

    headers: ({
      [\\"headerInlineParam\\"]: headerInlineParam,
      [\\"x-header-param\\"]: xHeaderParam
    }: {
      headerInlineParam: string;
      \\"x-header-param\\": string;
    }) => ({
      headerInlineParam: headerInlineParam,

      \\"x-header-param\\": xHeaderParam
    }),
    response_decoder: testParameterWithDashAnUnderscoreDefaultDecoder(),
    url: ({ [\\"path-param\\"]: pathParam }) =>
      \`\${basePath}/test-parameter-with-dash-and_underscore/\${pathParam}\`,

    query: ({ [\\"foo_bar\\"]: fooBar, [\\"request-id\\"]: requestId }) => ({
      [\\"foo_bar\\"]: fooBar,
      [\\"request-id\\"]: requestId
    })
  };
  const testParameterWithDashAnUnderscore: TypeofApiCall<TestParameterWithDashAnUnderscoreT> = createFetchRequestForApi(
    testParameterWithDashAnUnderscoreT,
    options
  );

  const testWithTwoParamsT: ReplaceRequestParams<
    TestWithTwoParamsT,
    RequestParams<TestWithTwoParamsT>
  > = {
    method: \\"get\\",

    headers: () => ({}),

    response_decoder: testWithTwoParamsDefaultDecoder(),
    url: ({ [\\"first-param\\"]: firstParam, [\\"second-param\\"]: secondParam }) =>
      \`\${basePath}/test-two-path-params/\${firstParam}/\${secondParam}\`,

    query: () => ({})
  };
  const testWithTwoParams: TypeofApiCall<TestWithTwoParamsT> = createFetchRequestForApi(
    testWithTwoParamsT,
    options
  );

  return {
    testAuthBearer: (withDefaults || identity)(testAuthBearer),
    testSimpleToken: (withDefaults || identity)(testSimpleToken),
    testMultipleSuccess: (withDefaults || identity)(testMultipleSuccess),
    testFileUpload: (withDefaults || identity)(testFileUpload),
    testResponseHeader: (withDefaults || identity)(testResponseHeader),
    testParameterWithReference: (withDefaults || identity)(
      testParameterWithReference
    ),
    testParameterWithDash: (withDefaults || identity)(testParameterWithDash),
    testParameterWithDashAnUnderscore: (withDefaults || identity)(
      testParameterWithDashAnUnderscore
    ),
    testWithTwoParams: (withDefaults || identity)(testWithTwoParams)
  };
}
"
`;

exports[`gen-api-models should support additionalProperties default value: additional-properties-default 1`] = `
"/**
 * Do not edit this file it is auto-generated by io-utils / gen-api-models.
 * See https://github.com/pagopa/io-utils
 */
/* eslint-disable  */

import * as t from \\"io-ts\\";
import { withDefault } from \\"@pagopa/ts-commons/lib/types\\";

type AdditionalpropsDefaultBase = t.TypeOf<typeof AdditionalpropsDefaultBase>;
const AdditionalpropsDefaultBase = t.dictionary(
  t.string,

  t.readonlyArray(t.number, \\"array of number\\"),

  \\"AdditionalpropsDefault\\"
);

// additional attributes

export const AdditionalpropsDefault = withDefault(AdditionalpropsDefaultBase, {
  test: [1000]
} as AdditionalpropsDefaultBase);

export type AdditionalpropsDefault = t.TypeOf<typeof AdditionalpropsDefault>;
"
`;

exports[`gen-api-models should support file uploads 1`] = `
"
    /****************************************************************
     * testFileUpload
     */

    // Request type definition
    export type TestFileUploadT = r.IPostApiRequestType<{readonly \\"file\\": { \\"uri\\": string, \\"name\\": string, \\"type\\": string }}, \\"Content-Type\\", never, r.IResponseType<200, undefined, never>>;
  
      
    export const testFileUploadDefaultResponses = {
      200: t.undefined
    };
  
      
    export type TestFileUploadResponsesT<A0 = undefined, C0 = undefined> = {
      200: t.Type<A0, C0>
    };
  
      export function testFileUploadDecoder<A0 = undefined, C0 = undefined>(overrideTypes: Partial<TestFileUploadResponsesT<A0, C0>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testFileUploadDefaultResponses as unknown as TestFileUploadResponsesT<A0, C0>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
        const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
      
        return d200
      }

      // Decodes the success response with the type defined in the specs
      export const testFileUploadDefaultDecoder = () => testFileUploadDecoder();"
`;

exports[`gen-api-models should support headers in response 1`] = `
"
    /****************************************************************
     * testResponseHeader
     */

    // Request type definition
    export type TestResponseHeaderT = r.IGetApiRequestType<{}, never, never, r.IResponseType<201, Message, \\"Location\\" | \\"Id\\">|r.IResponseType<500, undefined, never>>;
  
      
    export const testResponseHeaderDefaultResponses = {
      201: Message, 500: t.undefined
    };
  
      
    export type TestResponseHeaderResponsesT<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined> = {
      201: t.Type<A0, C0>, 500: t.Type<A1, C1>
    };
  
      export function testResponseHeaderDecoder<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined>(overrideTypes: Partial<TestResponseHeaderResponsesT<A0, C0, A1, C1>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<201, A0, \\"Location\\" | \\"Id\\">|r.IResponseType<500, A1, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testResponseHeaderDefaultResponses as unknown as TestResponseHeaderResponsesT<A0, C0, A1, C1>),
          ...(isDecoder(overrideTypes) ? { 201: overrideTypes } : overrideTypes)
        };

        
        const d201 = (type[201].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 201, \\"Location\\" | \\"Id\\">(201, undefined) 
        : r.ioResponseDecoder<201, (typeof type[201])[\\"_A\\"], (typeof type[201])[\\"_O\\"], \\"Location\\" | \\"Id\\">(201, type[201])) as r.ResponseDecoder<r.IResponseType<201, A0, \\"Location\\" | \\"Id\\">>;
      
        const d500 = (type[500].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 500, never>(500, undefined) 
        : r.ioResponseDecoder<500, (typeof type[500])[\\"_A\\"], (typeof type[500])[\\"_O\\"], never>(500, type[500])) as r.ResponseDecoder<r.IResponseType<500, A1, never>>;
      
        return r.composeResponseDecoders(d201, d500)
      }

      // Decodes the success response with the type defined in the specs
      export const testResponseHeaderDefaultDecoder = () => testResponseHeaderDecoder();"
`;

exports[`gen-api-models should support multiple success cases 1`] = `
"
    /****************************************************************
     * testMultipleSuccess
     */

    // Request type definition
    export type TestMultipleSuccessT = r.IGetApiRequestType<{}, never, never, r.IResponseType<200, Message, never>|r.IResponseType<202, undefined, never>|r.IResponseType<403, OneOfTest, never>|r.IResponseType<404, undefined, never>>;
  
      
    export const testMultipleSuccessDefaultResponses = {
      200: Message, 202: t.undefined, 403: OneOfTest, 404: t.undefined
    };
  
      
    export type TestMultipleSuccessResponsesT<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined, A2 = OneOfTest, C2 = OneOfTest, A3 = undefined, C3 = undefined> = {
      200: t.Type<A0, C0>, 202: t.Type<A1, C1>, 403: t.Type<A2, C2>, 404: t.Type<A3, C3>
    };
  
      export function testMultipleSuccessDecoder<A0 = Message, C0 = Message, A1 = undefined, C1 = undefined, A2 = OneOfTest, C2 = OneOfTest, A3 = undefined, C3 = undefined>(overrideTypes: Partial<TestMultipleSuccessResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>> | t.Type<A0, C0> | undefined = {}): r.ResponseDecoder<
    r.IResponseType<200, A0, never>|r.IResponseType<202, A1, never>|r.IResponseType<403, A2, never>|r.IResponseType<404, A3, never>
  > {
        const isDecoder = (d: any): d is t.Type<A0, C0> =>
          typeof d[\\"_A\\"] !== \\"undefined\\";

        const type = {
          ...(testMultipleSuccessDefaultResponses as unknown as TestMultipleSuccessResponsesT<A0, C0, A1, C1, A2, C2, A3, C3>),
          ...(isDecoder(overrideTypes) ? { 200: overrideTypes } : overrideTypes)
        };

        
        const d200 = (type[200].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 200, never>(200, undefined) 
        : r.ioResponseDecoder<200, (typeof type[200])[\\"_A\\"], (typeof type[200])[\\"_O\\"], never>(200, type[200])) as r.ResponseDecoder<r.IResponseType<200, A0, never>>;
      
        const d202 = (type[202].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 202, never>(202, undefined) 
        : r.ioResponseDecoder<202, (typeof type[202])[\\"_A\\"], (typeof type[202])[\\"_O\\"], never>(202, type[202])) as r.ResponseDecoder<r.IResponseType<202, A1, never>>;
      
        const d403 = (type[403].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 403, never>(403, undefined) 
        : r.ioResponseDecoder<403, (typeof type[403])[\\"_A\\"], (typeof type[403])[\\"_O\\"], never>(403, type[403])) as r.ResponseDecoder<r.IResponseType<403, A2, never>>;
      
        const d404 = (type[404].name === \\"undefined\\" 
        ? r.constantResponseDecoder<undefined, 404, never>(404, undefined) 
        : r.ioResponseDecoder<404, (typeof type[404])[\\"_A\\"], (typeof type[404])[\\"_O\\"], never>(404, type[404])) as r.ResponseDecoder<r.IResponseType<404, A3, never>>;
      
        return r.composeResponseDecoders(r.composeResponseDecoders(r.composeResponseDecoders(d200, d202), d403), d404)
      }

      // Decodes the success response with the type defined in the specs
      export const testMultipleSuccessDefaultDecoder = () => testMultipleSuccessDecoder();"
`;
